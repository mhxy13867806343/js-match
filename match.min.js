function match(value){const matchers=[];let defaultHandler=null;let executed=false;let isAsync=false;const api={with(pattern,handler){if (executed) return api;if (pattern instanceof RegExp){if (typeof value==='string' && pattern.test(value)){const matches=value.match(pattern);const result=typeof handler==='function' ? handler(value,matches) : handler;executed=true;return result;}}else if (typeof pattern==='function' && pattern.constructor.name==='GeneratorFunction'){const generator=pattern(value);let genResult=generator.next();if (!genResult.done && genResult.value){const result=typeof handler==='function' ? handler(value,generator) : handler;executed=true;return result;}}else if (pattern instanceof Promise){isAsync=true;return pattern.then(resolvedPattern=>{if (resolvedPattern===value){return typeof handler==='function' ? handler(value) : handler;}return api;});}else if (typeof pattern==='object' && pattern !==null){let allMatch=true;for (const [key,expectedValue] of Object.entries(pattern)){if (!value || value[key] !==expectedValue){allMatch=false;break;}}if (allMatch){const result=typeof handler==='function' ? handler(value) : handler;executed=true;return result;}}else if (pattern===value || (typeof pattern==='function' && pattern(value))){const result=typeof handler==='function' ? handler(value) : handler;executed=true;return result;}matchers.push({pattern,handler});return api;},async withAsync(pattern,handler){if (executed) return api;if (typeof pattern==='function' && pattern.constructor.name==='AsyncFunction'){try{const result=await pattern(value);if (result){const handlerResult=typeof handler==='function' ? await handler(value) : handler;executed=true;return handlerResult;}}catch (error){}}else if (pattern instanceof Promise){try{const resolvedPattern=await pattern;if (resolvedPattern===value || (typeof resolvedPattern==='function' && resolvedPattern(value))){const result=typeof handler==='function' ? await handler(value) : handler;executed=true;return result;}}catch (error){}}return this.with(pattern,handler);},otherwise(handler){if (executed) return api;defaultHandler=handler;return api;},run(){if (executed) return;for (const{pattern,handler}of matchers){if (pattern instanceof RegExp){if (typeof value==='string' && pattern.test(value)){const matches=value.match(pattern);return typeof handler==='function' ? handler(value,matches) : handler;}}else if (typeof pattern==='function' && pattern.constructor.name==='GeneratorFunction'){const generator=pattern(value);let genResult=generator.next();if (!genResult.done && genResult.value){return typeof handler==='function' ? handler(value,generator) : handler;}}else if (typeof pattern==='function'){if (pattern(value)){return typeof handler==='function' ? handler(value) : handler;}}else if (pattern===value){return typeof handler==='function' ? handler(value) : handler;}}if (defaultHandler){return typeof defaultHandler==='function' ? defaultHandler(value) : defaultHandler;}throw new Error(`No matching pattern found for value: ${value}`);},async runAsync(){if (executed) return;for (const{pattern,handler}of matchers){if (typeof pattern==='function' && pattern.constructor.name==='AsyncFunction'){try{const result=await pattern(value);if (result){return typeof handler==='function' ? await handler(value) : handler;}}catch (error){continue;}}else if (pattern instanceof Promise){try{const resolvedPattern=await pattern;if (resolvedPattern===value){return typeof handler==='function' ? await handler(value) : handler;}}catch (error){continue;}}else{try{const syncResult=this.run();if (syncResult !==undefined) return syncResult;}catch (error){continue;}}}if (defaultHandler){return typeof defaultHandler==='function' ? await defaultHandler(value) : defaultHandler;}throw new Error(`No matching pattern found for value: ${value}`);}};return api;}match.when=(value,patterns)=>{for (const [pattern,handler] of Object.entries(patterns)){if (pattern==='_') continue;if (pattern instanceof RegExp || (typeof pattern==='string' && pattern.startsWith('/') && pattern.endsWith('/'))){let regex=pattern;if (typeof pattern==='string'){regex=new RegExp(pattern.slice(1,-1));}if (typeof value==='string' && regex.test(value)){const matches=value.match(regex);return typeof handler==='function' ? handler(value,matches) : handler;}}else if (typeof pattern==='string' && pattern===value){return typeof handler==='function' ? handler(value) : handler;}else if (typeof pattern==='function' && pattern(value)){return typeof handler==='function' ? handler(value) : handler;}}if (patterns._){return typeof patterns._==='function' ? patterns._(value) : patterns._;}throw new Error(`No matching pattern found for value: ${value}`);};match.whenAsync=async (value,patterns)=>{for (const [pattern,handler] of Object.entries(patterns)){if (pattern==='_') continue;if (pattern instanceof Promise){try{const resolvedPattern=await pattern;if (resolvedPattern===value){return typeof handler==='function' ? await handler(value) : handler;}}catch (error){continue;}}else if (typeof pattern==='function' && pattern.constructor.name==='AsyncFunction'){try{const result=await pattern(value);if (result){return typeof handler==='function' ? await handler(value) : handler;}}catch (error){continue;}}else{try{return match.when(value,{[pattern]: handler,'_': null});}catch (error){continue;}}}if (patterns._){return typeof patterns._==='function' ? await patterns._(value) : patterns._;}throw new Error(`No matching pattern found for value: ${value}`);};match.chain=(value)=>{const chain={case(pattern,handler){if (pattern instanceof RegExp){if (typeof value==='string' && pattern.test(value)){const matches=value.match(pattern);const result=typeof handler==='function' ? handler(value,matches) : handler;return{value: result,matched: true};}}else if (typeof pattern==='function' && pattern.constructor.name==='GeneratorFunction'){const generator=pattern(value);let genResult=generator.next();if (!genResult.done && genResult.value){const result=typeof handler==='function' ? handler(value,generator) : handler;return{value: result,matched: true};}}else if (pattern===value || (typeof pattern==='function' && pattern(value))){const result=typeof handler==='function' ? handler(value) : handler;return{value: result,matched: true};}return chain;},async caseAsync(pattern,handler){if (typeof pattern==='function' && pattern.constructor.name==='AsyncFunction'){try{const result=await pattern(value);if (result){const handlerResult=typeof handler==='function' ? await handler(value) : handler;return{value: handlerResult,matched: true};}}catch (error){return chain;}}else if (pattern instanceof Promise){try{const resolvedPattern=await pattern;if (resolvedPattern===value){const result=typeof handler==='function' ? await handler(value) : handler;return{value: result,matched: true};}}catch (error){return chain;}}return this.case(pattern,handler);},default(handler){const result=typeof handler==='function' ? handler(value) : handler;return{value: result,matched: true};}};return chain;};match.rust=(value,arms)=>{for (const arm of arms){const [pattern,handler]=arm;if (pattern==='_'){return typeof handler==='function' ? handler(value) : handler;}if (pattern instanceof RegExp){if (typeof value==='string' && pattern.test(value)){const matches=value.match(pattern);return typeof handler==='function' ? handler(value,matches) : handler;}}else if (typeof pattern==='function' && pattern.constructor.name==='GeneratorFunction'){const generator=pattern(value);let genResult=generator.next();if (!genResult.done && genResult.value){return typeof handler==='function' ? handler(value,generator) : handler;}}else if (pattern===value || (typeof pattern==='function' && pattern(value))){return typeof handler==='function' ? handler(value) : handler;}}throw new Error(`No matching pattern found for value: ${value}`);};match.rustAsync=async (value,arms)=>{for (const arm of arms){const [pattern,handler]=arm;if (pattern==='_'){return typeof handler==='function' ? await handler(value) : handler;}if (typeof pattern==='function' && pattern.constructor.name==='AsyncFunction'){try{const result=await pattern(value);if (result){return typeof handler==='function' ? await handler(value) : handler;}}catch (error){continue;}}else if (pattern instanceof Promise){try{const resolvedPattern=await pattern;if (resolvedPattern===value){return typeof handler==='function' ? await handler(value) : handler;}}catch (error){continue;}}else{try{return match.rust(value,[[pattern,handler]]);}catch (error){continue;}}}throw new Error(`No matching pattern found for value: ${value}`);};match.generator=function* (condition){yield condition;};match.async=async (condition)=>{return await condition;};if (typeof module !=='undefined' && module.exports){module.exports=match;}else if (typeof window !=='undefined'){window.match=match;}